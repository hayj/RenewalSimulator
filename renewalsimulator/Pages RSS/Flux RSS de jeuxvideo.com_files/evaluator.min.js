/*! Copyright (c) 2021 Mediarithmics; All Rights Reserved */

"use strict";function computeBooleanOperator(e){return"AND"===e?(e,r)=>e&&r:(e,r)=>e||r}function computeBooleanComparisonReducer(e){switch(e){case"EQ":case"EQUAL":case"STARTS_WITH":case"MATCHES":return[!1,(e,r)=>e||r];default:return[!0,(e,r)=>e&&r]}}function computeNumberComparisonOperator(e){switch(e){case"EQUAL":case"EQ":return(e,r)=>e===r;case"NOT_EQ":case"NOT_EQUAL":return(e,r)=>e!==r;case"LT":return(e,r)=>e<r;case"LTE":return(e,r)=>e<=r;case"GT":return(e,r)=>e>r;case"GTE":return(e,r)=>e>=r;default:return(e,r)=>!1}}function computeStringComparisonOperator(e){switch(e){case"EQUAL":case"EQ":return(e,r)=>e===r;case"NOT_EQ":case"NOT_EQUAL":return(e,r)=>e!==r;case"MATCHES":return(e,r)=>-1!==e.toLowerCase().indexOf(r.toLowerCase());case"DOES_NOT_MATCH":return(e,r)=>-1===e.toLowerCase().indexOf(r.toLowerCase());case"STARTS_WITH":return(e,r)=>0===e.indexOf(r);case"DOES_NOT_START_WITH":return(e,r)=>0!==e.indexOf(r);case"CONTAINS":return(e,r)=>-1!==e.indexOf(r);case"DOES_NOT_CONTAIN":return(e,r)=>-1===e.indexOf(r);default:return(e,r)=>!1}}function evalOperator(e,r,t){if(null==e)return!1;if(Array.isArray(e))return e.some(e=>evalOperator(e,r,t));switch(r.type){case"NUMERIC":if(r.values&&0!==r.values.length){const[n,o]=computeBooleanComparisonReducer(r.operator),a=computeNumberComparisonOperator(r.operator);if("boolean"==typeof e)throw`Numeric field comparison expect a string or number value but got a 'boolean' for field '${t}'`;const s="string"==typeof e?parseFloat(e):e;return r.values.reduce((e,r)=>o(e,a(s,parseFloat(r))),n)}return!1;case"STRING":if(r.values&&0!==r.values.length){const t=String(e),[n,o]=computeBooleanComparisonReducer(r.operator),a=computeStringComparisonOperator(r.operator);return r.values.reduce((e,r)=>o(e,a(t,r)),n)}return!1;case"TIME":{if("boolean"==typeof e)throw`Numeric field comparison expect a string or number value but got a 'boolean' for field '${t}'`;const n=/now-(.*)d\/d/g.exec(String(r.values[0]));let o=parseInt(r.values[0]);n&&!isNaN(Number(n[1]))&&(o=Date.now()-24*Number(n[1])*3600*1e3);let a=void 0;if("string"==typeof e){if(a=Date.parse(e),isNaN(a))return!1}else a=e;switch(r.operator){case"BEFORE":return r.values&&a<o;case"BEFORE_OR_EQUAL":return r.values&&a<=o;case"AFTER":return r.values&&a>o;case"AFTER_OR_EQUAL":return r.values&&a>=o}}case"BOOLEAN":switch(r.operator){case"EQUAL":return r.values&&String(e)===r.values[0];case"NOT_EQUAL":return r.values&&String(e)!==r.values[0]}case"ENUM":switch(r.operator){case"EQUAL":return r.values&&e===r.values[0];case"NOT_EQUAL":return r.values&&e!==r.values[0];default:return!1}default:throw"Syntaxe error on Comparison name"}}function evalExistence(e,r){switch(r){case"EXISTS":return e;case"DOES_NOT_EXIST":return!e;default:throw"Syntaxe error: existence operation unkown"}}function evalObject(e,r,t){if(0===e.length)return!0;const n=computeBooleanOperator(r),o=!("AND"!==r);return e.reduce((e,r)=>n(e,t&&evaluateExpression(t,r)),o)}function evalFieldNode(e,r){return r.comparison&&r.field in e?r.field in e&&evalOperator(e[r.field],r.comparison,r.field):r.existence?evalExistence(r.field in e,r.existence):r.field in e}function computeArrayScore(e,r,t,n){if(t&&!e.some(e=>isNaN(Number(e[t]))))switch(r){case"SUM":return e.reduce((e,r)=>e+r[t],0);case"AVG":return e.reduce((e,r)=>e+r[t],0)/e.length;case"MIN":return e.reduce((e,r)=>r[t]<e?r[t]:e,e[0][t]);case"MAX":return e.reduce((e,r)=>r[t]>e?r[t]:e,e[0][t]);default:throw"score_function unknown"}let o=e.length;return"AVG"===r&&(o/=n),o}function evalObjectExpressionOnArray(e,r){let t;const n=e.filter(e=>evalObject(r.expressions,r.boolean_operator,e));if(0!==n.length&&r.score_function){if(r.score_field&&!e.some(e=>r.score_field in e))throw"Error: score_field does not exist in the processed object";t=computeArrayScore(n,r.score_function,r.score_field,e.length)>=(r.min_score?r.min_score:1)}else t=0!==n.length;return r.negation?!t:t}function evaluateExpression(e,r){switch(r.type){case"GROUP":return evalObjectExpressionOnArray([e],r);case"OBJECT":return r.field in e&&(Array.isArray(e[r.field])?evalObjectExpressionOnArray(e[r.field],r):evalObjectExpressionOnArray([e[r.field]],r));case"FIELD":return evalFieldNode(e,r);case"TAXONOMY_OBJECT":throw"TAXONOMY_OBJECT not implemented yet";default:return!1}}Object.defineProperty(window,"__esModule",{value:!0}),window.mics=window.mics||{},window.mics.evaluateExpression=evaluateExpression,window.mics&&window.mics._setEvaluator&&window.mics._setEvaluator(evaluateExpression);